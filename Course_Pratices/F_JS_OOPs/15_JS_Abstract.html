<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract</title>
</head>

<body>
    <!-- {{I think there is no any keyword like abstract in other programming language but techniques that allows us to work as abstract.}} -->
    <script>
        //Creating a constructor function  
        function Vehicle() {
            this.vehicleName = 'vehicleName';
            throw new Error("You cannot create an instance of Abstract class");

        }
        Vehicle.prototype.display = function () {
            return this.vehicleName;
        }
        var vehicle = new Vehicle();  
    </script>
    <!-- 

 Output:
tml:17  Uncaught Error: You cannot create an instance of Abstract class
    at new Vehicle (15_JS_Abstract.html:17:19)
    at 15_JS_Abstract.html:23:23
Vehicle @ 15_JS_Abstract.html:17
(anonymous) @ 15_JS_Abstract.html:23

     -->


    <!-- 
The given code is an example of creating an abstract class in JavaScript using constructor functions and prototypes.

In JavaScript, there is no built-in support for abstract classes. 
However, developers can create a similar concept by using certain techniques or conventions. 
In this code, the `Vehicle` function is intended to serve as an abstract class.

Inside the `Vehicle` constructor function, 
there is a line `throw new Error("You cannot create an instance of Abstract class");`. 
This line throws an error with a custom message whenever an attempt is made to create an instance 
of the `Vehicle` class. The intention here is to prevent direct instantiation of the abstract class.

The `Vehicle.prototype.display` method is defined using the prototype. 
It is a method that can be shared among instances of `Vehicle` or its derived classes. 
In this case, the `display` method returns the `vehicleName` property of the object.

Finally, an instance of `Vehicle` is created using the `new` keyword: `var vehicle = new Vehicle();`. 
Since the constructor throws an error, attempting to create an instance of the abstract class will result in an error being thrown.

In summary, the given code demonstrates an attempt to create an abstract 
class in JavaScript by throwing an error in the constructor when an instance is created. 
This approach aims to enforce the concept of an abstract class where instances cannot be created directly, 
but derived classes can extend and implement their own versions of the abstract class.
      -->
</body>

</html>

<!-- JavaScript doesn't have built-in support for abstract classes like some other programming languages such as Java or C#. However, you can implement abstract-like behavior through various techniques like using conventions, interfaces, or class structures.

### Emulating Abstract Classes in JavaScript:

1. **Using Conventions:**
   - Conventionally, you can create a base class and throw an error in its abstract methods, signaling that these methods need to be implemented by derived classes.
   ```javascript
   class Shape {
       calculateArea() {
           throw new Error('Abstract method must be implemented');
       }
   }

   class Circle extends Shape {
       calculateArea() {
           // Implement calculateArea() for Circle
           // Calculate area logic here
       }
   }

   const shape = new Shape(); // Throws an error if the abstract method is not implemented
   const circle = new Circle(); // Implements the abstract method
   ```

2. **Using Function Contracts (Interfaces):**
   - JavaScript doesn't have native interfaces, but you can create a contract using comments or explicit checks to ensure specific methods are implemented.
   ```javascript
   // Interface-like contract
   class IShape {
       calculateArea() {
           throw new Error('Method not implemented');
       }
   }

   class Circle extends IShape {
       calculateArea() {
           // Implement calculateArea() for Circle
           // Calculate area logic here
       }
   }

   const shape = new IShape(); // Throws an error as it's not meant to be instantiated directly
   const circle = new Circle(); // Implements the required method
   ```

3. **Using Factories:**
   - Another approach is to use factories that return objects with enforced methods.
   ```javascript
   function createShape() {
       return {
           calculateArea() {
               throw new Error('Method not implemented');
           }
       };
   }

   function createCircle() {
       const shape = createShape();
       shape.calculateArea = function() {
           // Implement calculateArea() for Circle
           // Calculate area logic here
       };
       return shape;
   }

   const shape = createShape(); // Throws an error if calculateArea() is not implemented
   const circle = createCircle(); // Implements the required method
   ```

While JavaScript doesn't have a specific syntax for abstract classes or interfaces, these approaches help mimic their behavior by setting expectations for certain methods to be implemented in derived classes or objects. Developers can use these patterns to achieve similar concepts of abstraction and contracts within their JavaScript code. -->